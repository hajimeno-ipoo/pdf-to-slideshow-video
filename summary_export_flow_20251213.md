# まとめ（2025-12-13）

## 背景 / 課題
- このリポジトリの元の設計だと、書き出した MP4 を「完成するまで全部 RAM に保持」しやすく、長尺（数百MB）で Mac がスワップ地獄→固まりやすい。
- 原因の中心は「完成物をメモリ上に作る」ターゲット（例: ArrayBuffer）＋ fastStart を in-memory にする構成。

## 目標
- 長尺でも RAM が増えにくいように、完成ファイルを RAM に置かず「生成しながらディスクへ保存」できる導線を作る。
- ただしブラウザ制約があるので、対応環境のみ省メモリ保存を使い、非対応では安全なフォールバックを用意する。

## 今回の実装（案A: MP4は保存ダイアログ→直書き）
- MP4 の書き出し開始時に `showSaveFilePicker()` を呼び、保存先（ファイル名含む）をユーザーに選ばせる。
  - キャンセル時は変換を始めない。
- Worker 側で MP4 の mux を `mp4-muxer` から **Mediabunny** に置換。
  - 保存先がある場合: `FileSystemFileHandle.createWritable()` → `StreamTarget` でディスクへ直書き（完成物を RAM に溜めない）。
  - 保存先が無い場合: `BufferTarget` で従来どおりメモリに生成して返す。
  - `fastStart: false`（メモリを増やしにくい設定）

### コード位置（現状）
- 保存先ピッカー: `App.tsx`
- Workerへハンドル渡し/完了後URL生成: `services/pdfVideoService.ts`
- WorkerのMP4生成（Mediabunny + StreamTarget/BufferTarget）: `services/videoWorkerScript.ts`

## レビュー指摘の反映（安定化）
- main側: `worker.onmessage` 内で例外が出ても Promise が未解決にならないように try/catch + cleanup + reject。
- worker側: 失敗時に `output.cancel()` と `writable.abort()` を試す finally を追加（ロック/中途半端ファイル残り対策）。

## これからのUI/体験案（次の段階）
- 出力形式は GIF を削除し、MOV に変更する（MP4/MOV）。

### 1) 編集画面に「保存先を設定」ボタン
- 1回だけダイアログで保存先＆ファイル名を決める。
- 「未設定」のまま「書き出し」を押したら警告を表示し、書き出しを止める。

### 2) 設定を保持（次から使える）
- 取れた `FileSystemFileHandle` を保持して、次回以降に再利用する。
  - ※ブラウザが許可する範囲で（主に Chromium 系）

### 3) 「書き出し」ボタンはダイアログ無しで保存
- 事前に設定済みの保存先へ、ダイアログ無しでディスク直書き。
- RAM が増えにくい挙動を維持。

### 4) 書き出し完了画面でプレビュー
- 完了後に保存済みファイルをプレビュー表示。

## フォールバック方針
- 「毎回ダイアログが出る」フォールバックは、`showSaveFilePicker` が使える環境でのみ可能。
- `showSaveFilePicker` が無いブラウザ（Safari/Firefox等）は、MP4/MOV書き出しを非対応として無効化し、Chrome/Edge推奨を表示する。

## 書き出し完了画面のボタン案
- 「ダウンロード」ボタンに別機能を持たせる案として、MP4省メモリ保存と相性が良いのは **サムネ画像書き出し**。
  - 1枚書き出し（現在フレーム/指定秒）
  - オプション: フレーム選択
  - オプション: zipでまとめて書き出し

### zipの注意
- 20枚くらいでも、解像度が高いと zip 作成時に RAM をそれなりに使うことがある。
- 対策: デフォ上限（例: 20）＋超えたら警告/確認、または JPEG(品質80等) も選べるようにする。

## MOVについて
- GIFの書き出しは削除し、代わりに MOV 形式に変更する。
- MOVも長尺は大きくなり得るので、MP4と同様に「完成物をRAMに溜めない（ディスク直書き）」前提で扱う。

## ブラウザ制約メモ
- ダイアログ無しで「任意の保存先フォルダに勝手に保存」や「Finderを直接開く」は、通常のWebアプリでは基本できない。
- 省メモリでやるなら、File System Access API を使える環境（主に Chromium）を前提に設計する。
